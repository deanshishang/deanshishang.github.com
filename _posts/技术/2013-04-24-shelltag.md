---
layout: post
title: Summary - Shell脚本
category: 技术
tags: Note
keywords:
description:
---

    最近做的项目需要用shell写脚本文件，大致的看了一下用法，为了掌握，我从昨天开始看shell脚本学习指南这本书。最近事情比较多，看书的时间压缩的太少了，看到第二章的时候需要了解正则表达式，推荐一篇文章——正则表达式30分钟入门教程，鸟哥的私房菜第三部分也都包括了，比较容易理解。这部分准备两个星期的空闲时间搞定。

* 简单性：是一个高级语言，通过它，简洁的表达复杂的操作；

* 可移植性：脚本无须修改就可以运行在不同的系统上；

* 开发容易：可以在段时间内完成一个功能强大又好用的脚本；

```
eg1: who | wc -l 计算用户个数  who 的输出是 wc的输入
```

shell的基本元素：

1，命令与参数：

```
eg2: cd work ; ls -l shishang.c 分号会分隔同一行的多条命令。shell会依次执行这些程序，如果换成&的话，shell将在后台执行前面的命令，不用等到该命令执行完成，就可以继续执行下一个命令。
```

shell 识别三种命令：

* 内建命令-- cd,read,echo,printf,test等；
		
* shell函数-- 可以像命令一样引用；
				
* 外部命令-- 就是由shell脚本所执行的命令,建立一个新的进程，进程为shell的一个副本，在新的进程里，PATH变量目录中，寻找特殊命令，在新的进程里取代执行中的shell程序并且执行，程序完成会直接从终端读取下一条命令，或者执行脚本里的下一条命令。

2，变量：可以分配值。

3，简单的echo输出：移植比较难，转义序列：\a 警示字符 \b 退格 \f 清除屏幕 等.

4，printf输出.

5，基本的I/O重定向：默认情况下，他们会读取标准输入，写入标准输出，并将错误信息标准输出，这类程序常常叫做过滤器（filter）,这几个都是终端。I/O重定向是指通过与终端进行交互，或者在脚本文件中修改设置，重新安排从哪里输入或者输出到哪里。

6，重定向与管道：<  改变标准输入 > 改变标准输出 >的符号会新建或者覆盖，>>不会覆盖；
管道：program1 | program2 将前者的标准输出修改为后者的标准输入。虽然 <  > 可以把输入与输出连接到文件，不过管道可以把两个以上的执行程中的程序衔接在一起。管道可以使得执行速度比临时文件程序快上10倍。

7，访问shell的脚本参数：who | grep $1 脚本文件中的意思是$1---执行的时候需要一个参数。

8，简单的执行跟踪：set -x 打开跟踪功能，set +x 关闭追踪功能，在脚本文件中也可以添加这两个命令。

* 当我们对性能要求不高的时候，希望尽快开发出程序并以较高级的方式工作时，使用脚本最佳时机。

* 鸟哥的私房菜：正则表达式（第十二章）linux基础中的基础，也是最难的部分

* 正则表达式是通过一些特殊字符的排列，用来搜索/替换/删除/一行或者多行字符串，就是用在字符串处理中的“表达式”。

* 正则表达式以行为单位处理字符串；正则表达式和“通配符“不一样。

#### 基础的正则表达式

* 通过grep选取字符串

```
grep [-acinv] '搜索字符串' filename
```
	
* a:在二进制文件中以文本方式搜数据 
* c:计算找到字符串的次数 
* i:忽略大小写 n:输出行号 
* v:反向选择

* grep在搜索数据的时候查找一个字符串，是以行为单位进行数据选取的，就是说，加入一个字符串在两行中出现了，这两行显示在屏幕上，其他行丢弃。

* 除了用于文件搜索之外，常常英语在输入/输出的数据处理中，例如常见的管道命令。

```
修改语系：# LANG=en # export LANG
```
```
搜索特定字符串：#grep -n 'the' test.txt   
```
```
利用[ ]搜索字符合集：#grep -n 't[ae]st' test.txt  
```

[ ] 中不管有几个字符，都代表其中一个字符，如果不想oo前边有g的话 命令用反向选择^  #grep -n '[^g]oo' text.txt  还有其他写法 [^a-z][^0-9]等

```
行首与行尾字符 ^ $  #grep -n '^the' text.txt  
表示寻找the在开头的行，
```

不想要开头是英文字母的行就这样写:

```
#grep -n '[^a-zA-Z]' text.txt (注:^在[ ]内表示反向选择，^在[ ]外表示开头字符)
```

要找‘ . ’ 结尾的字符行:

```
#grep -n '\.$' text.txt 加上了转义字符\ 
```

找空白行 ^$ 就行了 

```
#grep -v '^$' text.txt | grep -v  '^#' text.txt  把#开头的和空白行都去掉显示，节省了版面。
```

* 任意一个字符（.）和重复字符（*）：（.）表示绝对有一个字符的意思 如果至少有两个o以上怎么写 'ooo*' 即（*）表示重复0个或者多个前面的字符 所以（o*）表示拥有空字符或者一个以上的o。

* 寻找字符开头和结尾都是g的 ‘g*g’ 是不行的，要用‘g.*g’表示，即(.*)

* 表示0个或者多个任意字符。如果想找任意都是数字的行用什么？ '[0-9][0-9]*' 就可以了。

* 限定连续重复字符范围{ }：要找出g后边接2--5个o的话怎么写？ #grep -n 'go\{2,5\}' text.txt 如果要找两个或者两个以上的goo....g 可以这么使用 ‘gooo*g’ 或者 'go\{2,\}g'。

**重要特殊字符：**

* grep -n \' text.txt  搜索有单引号的那一行；

* . 代表任意一个字符，也一定是一个字符；

* \*为重复前一个字符的符号，所以前边必须有一个字符，任意字符则为 .*；

* \{n\} 连续重复n个前一个字符，\{n,\} 连续重复n 个以上前边的字符；

* [^A-Z]代表非大写字母的行，每行都会列出来，应为每一行都有非大写字母；

* 正则表达式vs通配符：ls -l * 代表列出任意文件名的文件 ls -l a* 代表以a开头的文件，在正则表达式中则为：ls | grep -n '^a.*'。

#### 扩展的正则表达式

* 如果使用扩展表达式，可以这样写 #egrep -v '^$|^#' test.txt ,比之前的例子简单；

* + ：重复一个或者一个以上的字符 #egrep -n 'go+d' test.txt 代表一个或者一个以上的o；

* ?：0个或者一个字符 'go?d' 即'gd'或者'god'；

* | ：或的方式找字符串，‘gd|dog’ 两者其中一个；

* ()：找出用户组字符串，‘g(la|oo)d’  搜索glad或者good； 

* ！或者< 这样的字符不是特殊字符，不用转义符；

#### 格式化显示，sed，awk工具

* 格式化显示：printf \xNN NN为两位数字，可以转换数字成为字符；%ns %nd,多少个字符或者数字

* sed 工具：分析标准输入的数据，数据经过处理之后，再输出到标准输出;

```
sed [acdips]
a,新增 
c,替换 
d,删除 
i,插入 
p,打印 
s,搜索或者替换 
```

```
nl ./etc/passwd | sed '2a drink tea' 2行后加了字符，2i的话是之前加；
nl /etc/passwd | sed '2,5c number' 替换2到5行；
nl /etc/paswd | sed -n '2,5p' 仅仅显示2到5行 -n 表示只显示经过sed处理的；
ifconfig eth0 | grep 'inet' | sed 's/^.*addr://g' | sed 's/Bcast.*$//g' 掐头去尾。
```

* awk工具：awk倾向于一种一行中分成数个“字段来进行处理” 适合小型的数据。 

	* awk '条件类型{动作}......' filename 处理每一行字段内的数据，默认的字段分割符为空格或者tab；

	* last可以将登录者取出来，想取出来登录者和IP地址中间用tab分开，# last | awk '{print $1 “\t” $3}' 
			
	* $0代表一整行数据的意思。

	* NF每一行拥有的字段数;
							
	* NR当前awk处理的是第几行的数据;
									
	* FS当前的分割符号，默认为空格健。

```
last | awk '{print $1 "\t line: " NR "\t columes: " NF}' 

要查看第三行小于10一下的数据，并且仅仅列出帐号与第三栏

cat /etc/passwd | awk ' BEGIN {FS=":"} $3<10 {print $1 "\t" $3}'。

一个查表统计的例子（P257）

cat pay.txt | awk 'NR==1{printf "%10s %10s %10s %10s %10s\n", $1,$2,$3,$4,"TOTAL"} NR>=2{total = $2+$3+$4 printf "%10s,%10d,%10d,%10d,%10.2f\n",$1,$2,$3,$4,total}'
```
