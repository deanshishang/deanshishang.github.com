---
layout: post
title: Summary - Shell脚本
category: 技术
tags: Note
keywords:
description:
---

    最近做的项目需要用shell写脚本文件，大致的看了一下用法，为了掌握，我从昨天开始看shell脚本学习指南这本书。最近事情比较多，看书的时间压缩的太少了，看到第二章的时候需要了解正则表达式，推荐一篇文章——正则表达式30分钟入门教程，鸟哥的私房菜第三部分也都包括了，比较容易理解。这部分准备两个星期的空闲时间搞定。

* 简单性：是一个高级语言，通过它，简洁的表达复杂的操作；

* 可移植性：脚本无须修改就可以运行在不同的系统上；

* 开发容易：可以在段时间内完成一个功能强大又好用的脚本；

```
eg1: who | wc -l 计算用户个数  who 的输出是 wc的输入
```

shell的基本元素：

1，命令与参数：

```
eg2: cd work ; ls -l shishang.c 分号会分隔同一行的多条命令。shell会依次执行这些程序，如果换成&的话，shell将在后台执行前面的命令，不用等到该命令执行完成，就可以继续执行下一个命令。
```

shell 识别三种命令：

* 内建命令-- cd,read,echo,printf,test等；
		
* shell函数-- 可以像命令一样引用；
				
* 外部命令-- 就是由shell脚本所执行的命令,建立一个新的进程，进程为shell的一个副本，在新的进程里，PATH变量目录中，寻找特殊命令，在新的进程里取代执行中的shell程序并且执行，程序完成会直接从终端读取下一条命令，或者执行脚本里的下一条命令。

2，变量：可以分配值。

3，简单的echo输出：移植比较难，转义序列：\a 警示字符 \b 退格 \f 清除屏幕 等.

4，printf输出.

5，基本的I/O重定向：默认情况下，他们会读取标准输入，写入标准输出，并将错误信息标准输出，这类程序常常叫做过滤器（filter）,这几个都是终端。I/O重定向是指通过与终端进行交互，或者在脚本文件中修改设置，重新安排从哪里输入或者输出到哪里。

6，重定向与管道：<  改变标准输入 > 改变标准输出 >的符号会新建或者覆盖，>>不会覆盖；
管道：program1 | program2 将前者的标准输出修改为后者的标准输入。虽然 <  > 可以把输入与输出连接到文件，不过管道可以把两个以上的执行程中的程序衔接在一起。管道可以使得执行速度比临时文件程序快上10倍。

7，访问shell的脚本参数：who | grep $1 脚本文件中的意思是$1---执行的时候需要一个参数。

8，简单的执行跟踪：set -x 打开跟踪功能，set +x 关闭追踪功能，在脚本文件中也可以添加这两个命令。

* 当我们对性能要求不高的时候，希望尽快开发出程序并以较高级的方式工作时，使用脚本最佳时机。

* 鸟哥的私房菜：正则表达式（第十二章）linux基础中的基础，也是最难的部分

* 正则表达式是通过一些特殊字符的排列，用来搜索/替换/删除/一行或者多行字符串，就是用在字符串处理中的“表达式”。

* 正则表达式以行为单位处理字符串；正则表达式和“通配符“不一样。

#### 基础的正则表达式

* 通过grep选取字符串

```
grep [-acinv] '搜索字符串' filename
```
	
* a:在二进制文件中以文本方式搜数据 
* c:计算找到字符串的次数 
* i:忽略大小写 n:输出行号 
* v:反向选择

* grep在搜索数据的时候查找一个字符串，是以行为单位进行数据选取的，就是说，加入一个字符串在两行中出现了，这两行显示在屏幕上，其他行丢弃。

* 除了用于文件搜索之外，常常英语在输入/输出的数据处理中，例如常见的管道命令。

```
修改语系：# LANG=en # export LANG
```
```
搜索特定字符串：#grep -n 'the' test.txt   
```
```
利用[ ]搜索字符合集：#grep -n 't[ae]st' test.txt  
```

[ ] 中不管有几个字符，都代表其中一个字符，如果不想oo前边有g的话 命令用反向选择^  #grep -n '[^g]oo' text.txt  还有其他写法 [^a-z][^0-9]等

```
行首与行尾字符 ^ $  #grep -n '^the' text.txt  
表示寻找the在开头的行，
```

不想要开头是英文字母的行就这样写:

```
#grep -n '[^a-zA-Z]' text.txt (注:^在[ ]内表示反向选择，^在[ ]外表示开头字符)
```

要找‘ . ’ 结尾的字符行:

```
#grep -n '\.$' text.txt 加上了转义字符\ 
```

找空白行 ^$ 就行了 

```
#grep -v '^$' text.txt | grep -v  '^#' text.txt  把#开头的和空白行都去掉显示，节省了版面。
```

* 任意一个字符（.）和重复字符（*）：（.）表示绝对有一个字符的意思 如果至少有两个o以上怎么写 'ooo*' 即（*）表示重复0个或者多个前面的字符 所以（o*）表示拥有空字符或者一个以上的o。

* 寻找字符开头和结尾都是g的 ‘g*g’ 是不行的，要用‘g.*g’表示，即(.*)

* 表示0个或者多个任意字符。如果想找任意都是数字的行用什么？ '[0-9][0-9]*' 就可以了。

* 限定连续重复字符范围{ }：要找出g后边接2--5个o的话怎么写？ #grep -n 'go\{2,5\}' text.txt 如果要找两个或者两个以上的goo....g 可以这么使用 ‘gooo*g’ 或者 'go\{2,\}g'。

**重要特殊字符：**

* grep -n \' text.txt  搜索有单引号的那一行；

* . 代表任意一个字符，也一定是一个字符；

* \*为重复前一个字符的符号，所以前边必须有一个字符，任意字符则为 .*；

* \{n\} 连续重复n个前一个字符，\{n,\} 连续重复n 个以上前边的字符；

* [^A-Z]代表非大写字母的行，每行都会列出来，应为每一行都有非大写字母；

* 正则表达式vs通配符：ls -l * 代表列出任意文件名的文件 ls -l a* 代表以a开头的文件，在正则表达式中则为：ls | grep -n '^a.*'。

#### 扩展的正则表达式

* 如果使用扩展表达式，可以这样写 #egrep -v '^$|^#' test.txt ,比之前的例子简单；

* + ：重复一个或者一个以上的字符 #egrep -n 'go+d' test.txt 代表一个或者一个以上的o；

* ?：0个或者一个字符 'go?d' 即'gd'或者'god'；

* | ：或的方式找字符串，‘gd|dog’ 两者其中一个；

* ()：找出用户组字符串，‘g(la|oo)d’  搜索glad或者good； 

* ！或者< 这样的字符不是特殊字符，不用转义符；

#### 格式化显示，sed，awk工具

* 格式化显示：printf \xNN NN为两位数字，可以转换数字成为字符；%ns %nd,多少个字符或者数字

* sed 工具：分析标准输入的数据，数据经过处理之后，再输出到标准输出;

```
sed [acdips]
a,新增 
c,替换 
d,删除 
i,插入 
p,打印 
s,搜索或者替换 
```

```
nl ./etc/passwd | sed '2a drink tea' 2行后加了字符，2i的话是之前加；
nl /etc/passwd | sed '2,5c number' 替换2到5行；
nl /etc/paswd | sed -n '2,5p' 仅仅显示2到5行 -n 表示只显示经过sed处理的；
ifconfig eth0 | grep 'inet' | sed 's/^.*addr://g' | sed 's/Bcast.*$//g' 掐头去尾。
```

* awk工具：awk倾向于一种一行中分成数个“字段来进行处理” 适合小型的数据。 

	* awk '条件类型{动作}......' filename 处理每一行字段内的数据，默认的字段分割符为空格或者tab；

	* last可以将登录者取出来，想取出来登录者和IP地址中间用tab分开，# last | awk '{print $1 “\t” $3}' 
			
	* $0代表一整行数据的意思。

	* NF每一行拥有的字段数;
							
	* NR当前awk处理的是第几行的数据;
									
	* FS当前的分割符号，默认为空格健。

```
last | awk '{print $1 "\t line: " NR "\t columes: " NF}' 

要查看第三行小于10一下的数据，并且仅仅列出帐号与第三栏

cat /etc/passwd | awk ' BEGIN {FS=":"} $3<10 {print $1 "\t" $3}'。

一个查表统计的例子（P257）

cat pay.txt | awk 'NR==1{printf "%10s %10s %10s %10s %10s\n", $1,$2,$3,$4,"TOTAL"} NR>=2{total = $2+$3+$4 printf "%10s,%10d,%10d,%10d,%10.2f\n",$1,$2,$3,$4,total}'
```

#### 文件数据比较与显示

diff: sed以后有两个操作的时候都要加上-e'

```
diff [-bBi] 

b忽略一行中有多个空白的 

B忽略空白行 

i忽略大小写的，也可以比较目录，比较不同目录相同文件名子的不同。
```

* cmp:用位比较，可以比较二进制文件，diff是行，它是位

* patch:可以将旧文件升级为新文件，

```
mkdir /tmp/old; cp /etc/passwd /tmp/old   

mkdir /tmp/new; cp/tmp/test/passwd /tmp/new  

cd /tmp; diff -Naur old/ new/ > test.patch 

cd /tmp/old;  patch -p1 < /tmp/test.patch  

p1为减掉一层目录。 patch.file即为补丁文件，私房菜中有详细介绍。
```

---

* 在Linux里边，命令行方式其实是相当于bash的工具与接口，在linux中bash是默认的shell。

* 计算机要输出音乐的时候，计算机都要做些什么：

	* 硬件的支持，硬件设备，否则不会有声音；

	* 操作系统的核心支持这个芯片集，还要提供驱动程序；

	* 用户要发出命令，告诉计算机要发声音，即输出的命令；

	* 基本的输出步骤就是这样了，我们就是通过shell将输入的命令与核心沟通，让核心来控制硬件。

	* 通常工作的是硬件，控制硬件的是核心，用户通过shell与核心进行沟通。

	* kernel是最内层的核心，核心是操作系统最底层的东西，shell在最外头。

	* 当登陆的时候，系统会给我们一个shell让我们工作，登陆取得的shell记录在/etc/passwd里边，每一行的最后一个数据，就是系统提供给的shell。
							 
* Bash Shell 的功能

	* 命令记忆功能：能够记住使用过的命令在~/.bash_history中

	*  命令与文件补全功能

	*  命令别名设置功能(alias)，eg:  # alias lm="ls -al"

	*  作业控制，前台，后台控制

	* 通配符，加快操作进度

	* Bash Shell 的内置命令：用type命令观察即可。


```
type [-tpa] name  其中，type -p touch 类似的能查看命令路径，功能类似于which。
```

* 执行命令 

```
command [-option] parameter1 parameter2 ...
```

* 说明：有时候完整参数的名称会输入--符号，例如--help，命令太长的时候使用\符号来转义回车键，不过\后面要立即接特殊字符。

* 当我们顺利的在终端(tty)上登录以后，Linux就会根据/etc/passwd的文件设置，给我们一个shell，默认就是bash。

		  
* Shell的变量功能（变量就是以一组文字或者符号，来替换一些设置或者是一串保留的数据）

* 为了简化整个运行流程，我们通过某个变量的功能，让这个变量可以根据不同用户而更改内容，当然可以更改这些变量，但如果变量直接于套件中，那么，当修改某些参数之后，套件就必须要重新编译，所以变量真的很方便.

* 使用：在大型的脚本当中使用变量，比如一些目录，修改所有就麻烦了，所以用变量就改动一处，在正确登录之后，系统需要一些变量提供数据访问，或者设置一些参数值，现实色彩等，所以就要读入一些“环境变量”，这些环境变量如PATH HOME MAIL SHELL等等，区别一般变量，这些大写。

* 变量的获取与设置：echo, unset

* 设置规则：

	* 变量设置的时候，等号左右边不能直接连空格符；

	* 若有空格符。可以使用双引号或者单引号将变量内容结合起来，但是注意，双引号内的特殊字符可以保持变量特性，但单引号内的特殊字符仅为单一字符。就是双引号内的特殊字符可以不用管，单引号内的必须加上转义符。（enter 空格 $ / ' 等）；

* 在hell环境中有多少变量呢，可以用两个命令来查看：env , export

	* 一些环境变量的说明：env 命令会显示许多环境变量：其中比较关键的几个是
	
	```
	HOME 用户的家目录
					
	SHELL 告诉我们这个环境是用的shell是哪个程序，如果是bash 默认为 /bin/bash。

	ENV 这是用户的个性化环境设置文件的读取文件

	PATH 执行文件的搜索路径，是有顺序的 /root/.bashrc

	LANG 这个很重要，就是语系文件

	RANDOM 这个是随机数变量，当前大多数版本都有随机数发生器。就是/dev/random文件

	declare -i number=$RANDOM*10/32767 ; echo $number  打印0到9 的随机数串命令之中，还需要通过其他命令提供的信息，可以使用这样的方式“·command·” 不是单引号，是数字键1边上的；

	```

* 如果该变量要在其他子程序中执行，需要用export编程环境变量；

* 取消变量的方法：unset

* 这个例子不可以：将name内容多出一个yes------# name=$nameyes 错误, name="$name"yes正确 ame=${name}yes正确

* 刚刚设置的变量在下一个shell程序中用？一般情况下，子进程内无法使用父进程定义的变量，都是用export变成.

* 如何进入到当前核心的模块目录？# cd /lib/modules/`uname -r`/kernel  其中``中的取得内核版本。

* 双引号和单引号的区别最大在于，双引号仍然可以保持变量的内容，但是单引号只能是一般字符，而不会有特殊符号。

```
#name=Vbird 
#echo $name  
#myname="$name its me" 
#echo $myname 
#myname='$name its me' 
#echo $myname 
单引号的话$name 失去了原有的意义，打印不是想要的。
```


#### 变量的用途

* 简化路径名称；

* 另一个需要变量的情况是在脚本里，存储路径的设置

* 当然如果是与系统中断环境相关的设置，很多时候也是利用变量帮助实现的，即‘环境变量’


* 环境变量的功能

	* 环境变量可以帮助我们实现许多功能，包括家目录的修改，提示符的显示，执行文件的搜索路径等等。

	* 我们使用的shell环境中有多少变量呢，可以用两个命令来查看：env , export

	* 一些环境变量的说明：env 命令会显示许多环境变量：其中比较关键的几个是

```
HOME 用户的家目录

SHELL 告诉我们这个环境是用的shell是哪个程序，如果是bash 默认为 /bin/bash。

ENV 这是用户的个性化环境设置文件的读取文件

PATH 执行文件的搜索路径，是有顺序的 /root/.bashrc

LANG 这个很重要，就是语系文件

RANDOM 这个是随机数变量，当前大多数版本都有随机数发生器。就是/dev/random文件

declare -i number=$RANDOM*10/32767 ; echo $number  打印0到9 的随机数
```

* 在bash环境下，还有一些重要的变量，这些变量是在‘shell环境下有效· 如果是在子程序中，变量的值就不同了，其他自定义的变量以及所有的变量使用set命令都会显示，使用大写字母设置的变量一般为系统内定需要的变量。

* 使用set  除了会将系统默认值显示出来，自己设置的也会显示出来，当有多个人在线的时候，自己的变量只能自己使用，除非改的是系统默认的参数文件 如/etc/profile 不会干扰到别人。如果想要变量没吃都出现在登陆的自动设置好，必须将设置好写入登录时加载的设置文件。

* $ 关于本shell的ID 表示当前这个进程的进程号，想要知道命令是：# echo $$

* ? 上一个执行命令的回传代码。成功返回0

* OSTYPE HOSTTYPE MACHTYPE 主机硬件与核心的等级，与程序安装有关，

* PS1: 提示符的设置，命令提示符的设置

```
[root@linux /home/shishang 16:50 #12]# 应该用这样来设置PS1  
PS1='[\u@\h \W \A #\#]\$' 其中 \h 表示仅仅取主机的名称的第一个名字 \u表示当前用户的账号名称 \W 利用basename取得的共组目录名称，仅会列出最后一个目录名字 \A 显示时间 \#表示执行的第几个命令 \$提示符 如果是root则为# 否则为$ 
```

* 自定义变量转换成环境变量：

```
export 变量
```

* 环境变量与自己定义的变量，主要是由变量是否可以被子程序调用区别的

* 父进程中定义的自己变量不会继续存在，只有环境变量存在于子程序中。 如果想要是自定义的变量继续在子程序之中运行使用就只想上边的命令。直接export所有环境变量都显示出来。
	  
* 语系文件的变量（locale)

```
locale -a
中文语系支持两种以上的编码，热门的utf-8编码，通过LANG 等等相关的可以修改这编码，仅仅需设置LANG即可，语系文件都保存在/usr/lib/local目录中，
```

* 变量的有效范围

	* 被export的环境变量存在于子程序中，其他自定义的变量不会存在子程序中，只在当前的shell环境中存在，除非使用export把自定义变量转换成环境变量。比如两个文件sh1.sh 和sh2.sh 如果后者回去引用前者的变量，这个时候在前者中必须export设置，否则变量将无法再两个版本之间互用，当这个脚本文件执行完毕之后，变量刚刚的设置无效了。

* 环境变量可以让子程序引用的原因：

	* 启动一个shell的时候，操作系统分配一块内存个shell使用，这个区域的变量可以让子程序访问。

	* 利用export功能，可以让变量写到上述内存中（环境变量）

	* 当加载另外一个shell的时候（启动子程序，离开原来的程序），子程序可以将父shell的环境变量导入自己的环境变量区域

* 变量的键盘读取数组与声明 read array declare

	* 变量的设置也可以通过键盘， 我们可以声明这个变量的属性。例如数组或者数字。

```
read [-pt] variable       
-p后边可以接提示符-t后面接等待的描述, 用户通过键盘输入内容, 
read atest    
输入 this is test  
echo $atest  
显示this is test 
-p -t 同理 
read -p "please...." -t 30 nbamed  -p 使用后会美观一些。
```
```
declare [-aixr] variable   
-a定义为数组variable 
-i数字
-x将其变成环境变量
-r 设置成只读，不能修改也不能unset。
```

```
sum=100+50
echo $sum
100+50

declare -i sum=100+50
echo $sum
150
```

* 数组在脚本中比较常用：

	* 在bash中数组的设置方式为:var[index]=content 一个数组名字为var，

```
var[1]="smallming"
var[2]="bigming"
echo "${var[1]}, ${var[2]}"
建议直接以${数组}方式读取，正确无误。
``` 

* 与文件系统及程序的限制关系：

```
ulimit [-SHacdflmnpstv] 配额
```
* 同时有10人登陆或更多的时候，内存要用的大了就要限制。bash 是可以限制用户的某些系统资源的，包括可以打开的文件数量，可以使用的cpu时间，可以使用的内存总量等，用ulimit设置;

```
例如:
ulimit -a 列出所有的限制额度，
ulimit -f 1024, 限制文件大小。
```

* 附加变量的设置功能：

	* 假设变量名是vbird 设置为/home/vbird/testing/text.x.sh

```
#echo ${vbird##/*/}  #echo ${vbird#/*/}  前者打印出 完整路径，后者打印出/home/
#echo ${vbird%%/*/} 完整路径 #echo ${vbird%/*}只删除text.x.sh
#echo ${vbird/testing/TEST}字符串替换，如果是//则后边的都替换。
```
  
* 命令别名与历史命令：

  	* 命令别名设置：

	```
	#alias rm='rm -i'   #unalias rm  设置与取消设置
	```

	* 历史命令：

	```
	#history [n]  列出n行 #history -c 全部清除  [-raw] histfile man查询下
	```

