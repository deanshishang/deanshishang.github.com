---
layout: post
title: 嵌入式课堂小结
category: Note
---

###表达式

#### 数据类型

* 内置类型：int short chart double ;

* 构造类型：结构体 指针 数组 枚举 函数 ;

* 空类型：void ;

* int   short long                     三种整型;

   |      |     |

  4byte 2byte (32bit 4byte；64bit 4byte）

#### tag 知识点

* CPU 指令个数 寄存器指令个数 ————> 体系结构；
    
* intel amd --> i386 体系结构 地址总线：32位 访问的地址总量：2*2...(32),4G.

* 在32位上8个字节用long long（long double 16字节）

* c89中用long long;

* gcc a.c -o app -sd=c89;

* 运算符：size of()字节数求取；

* typeof()求变量类型的名字；

* int-->32bits ;

* 在内存中两种稳态：二进制表示 ;

* 编码方式：补码 ;

* 0有唯一编码，计算速度快;

* 32位 第一位;符号位（1负0正）；

* 范围-2（8n-1）~~2(8n-1)-1;n为字节数，量级int 10(9),short 10(5);

* 如果超出范围就溢出了（overfloat）;

* 浮点数：float型，作为协处理器集成于cpu中；用移码表示，常用于科学图形计算当中，有符号位，后面31位中前M位为数值，后N位为精度；

* 浮点计算速度慢于整数;

* 中央处理器『协处理器，中央处理单元 内部管理单元（memory management unit）(虚拟地址 物理地址)』之所以在主板上消失了是因为都集成于CPU中了。计算机中处理整数速度快;

* char 字符型数据,占用一个字节，存储字符对应的ASCII码；

* 除法永远向下去整;

* ALU(agrithal logical uint)算数逻辑单元 只做加法和移位运算;

* 编程中注意速度避免用除法 乘法可以;

* 逻辑运算符 支持短路运算（short circuit）;

     |

  char *who;

  (strcmp(who,"root")!=0)&&(printf("you are not root"));

  等同于 if(strcmp(who,"root")!=0){printf("you are not root")};

* 隐式类型转换-->自动统一到下一个类型进行运算 小类型转换成大类型 保持精度;
 
  |

  char-->short-->int -->unsigned int -->long-->double<--float;

### 数组与字符串

#### 数组

变长数组 malloc int a[n];与编译器相关其采用默认的N值进行分配 不显示错误；

例子：int a[10];a[10]不行，结果不可预测，造成数组越界了；

* %d: 输出转换成十进制有符号整型
* %u：无符号整型
* %o，%x：用来查看 不用有符号
* %s：字符串，%c字符
* %p：专门用来打印地址，pointor

####存储模式
* 小端法（little-endian）i386体系：高位存高字节，低位存低字节。

* 在编程时用虚拟地址，不是物理地址，内存不够时可以用外存。缺页异常。

* 访问速度：缓存50ns，内存100ns，磁盘100us，移位运算1ns，/，%10ns。

* 局部性原理：数据最好连续性访问。

* 解释操作系统：分时复用。即不同程序之间相互一直切换。

* 虚拟的经过MMU进行映射（内核提供算法）物理的，disc与内存进行交换，硬盘中有用的换取内存中无用的（换页机制，即缺页异常）。

* 佐证:访问占用内存很大的时候，不断用页面切换到磁盘中暂存即磁盘与内存的交互。

####串

* 字符串：特殊的字符数组；多了一个结束标记“\0”，字符串首地址开始到“\0”之间的内容。例如五个字符的串是六个字节。

* 字符串的初始化：

	** char buf[1024]="hello";前5个是hello第六个是\0，以后的也都是“\0”。char buf[5]="hello";是错误的 六个字节。

 ** int a[10];

** sizeof(a),求取字节数为40。

** char buf[]="hello";

** sizeof(buf)，为6.

** sizeof(&buf[0]),地址是32位，即4个字节。

** 常用函数：输入一个串 char buf[1024];

** scanf("%s",buf);\\输入一个串到buf中

** gets(buf);

** puts(buf);\\打印串

** strlen 求字符串长度；strcmp 字符串比较；strcpy 字符串复制；strcat 字符串连接；    

** scanf函数对空格非常敏感（空格与回车等价），这时只能用gets（）函数。

** gets()函数没有限制输入的字符，只传输了首地址，会导致stack smash(栈崩溃)。


