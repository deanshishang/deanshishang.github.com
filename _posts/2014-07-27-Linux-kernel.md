---
layout: post
title: Linux内核设计与实现之内核
category: Note
---

### linux内核：

Linux系统的基础是内核，C库，工具集和系统的基本工具，如登录程序和Shell；

通常来说，用户在显示屏上看到的东西就是操作系统，是指在整个系统中负责完成最基本功能和系统管理的那些部分，包括shell登录程序，设备驱动程序，内核，启动引导程序，或者其他种类的用户界面，基本的文件管理工具和系统工具；

内核是操作系统的内在核心，系统的其他部分必须依赖这部分软件才能运行，比如硬件设备管理以及合理分配资源，内核是管理者或者操作系统核心，通常由一个负责中断响应程序的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理多个进程地址从而进行内存管理的内存管理程序和网络，进程间通信等系统服务程序共同组成；

系统中运行的程序通过系统调用来和内核进行通信，内核独立于应用程序，通常有独立的内存空间和访问所有硬件系统的权限，这种系统态和被保存起来的内存空间称之为内核空间，同样也有用户空间；

当一个应用程序执行一条系统调用说成是内核代其执行，进一步解释，应用程序通过系统调用在内核空间运行，内核被称之为运行在进程上下文中，这种应用程序通过系统调用陷入内核，是应用程序运行的基本方式；

内核还负责管理硬件设备，所有的体系结构都包括中断机制，当硬件设备祥和系统通信的时候，首先要发出一个异步的通信信号去打断处理器的执行，继而打断内核的执行，中断对应这一个中断号，内核通过它查找对应的中断服务程序，并响应和处理中断。中断服务程序都不在进程上下文中执行，为了保证中断程序能够第一时间响应处理程序，设计在一个单独的中断上下文中运行；

这些上下文代表着内核的活动范围，可以将每个处理器在任何指定时间地点上的活动必然概括为三者之一：

* 运行于用户空间，执行用户进程；

* 运行于内核空间，处于进程上下文，代表特定的进程执行；

* 运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断。

例如，当CPU空闲时候，内核就运行一个空进程，在内核空间中，处于进程上下文。

小结，应用程序处于内核子系统的上边通过系统调用接口连接，接口上是用户空间，接口下包括设备驱动程序是内核空间，再以下就是硬件；

#### Linux内核与传统UNIX比较

linux内核运行在单独的内核地址空间上，吸取了微内核的精华，引以为豪的是：

* 模块化设计

* 抢占式内核

* 支持内核线程

* 动态装在内核模块

* 所有事情都运行在内核态，直接调用函数，无需微内核的消息传递

显著差异如下:

* L支持动态加载内核模块

* L支持多处理(SMP)机制

* L内核可以抢占

* L对线程的支持，不区分进程和其他一般进程，对于内核来说，所有进程都一样，只不过有一些共享资源而已

* L提供具有设备类的面向对象的设备模型，热插拔时间，以及用户空间的设备文件系统

* L实现了自由这个词的精髓

##### Linux内核版本

2.6.26.1  2是主版本号，6是从版本号，偶数是稳定版，26是修订版本号，1是稳定版本号。

### 从内核出发：

#### 获取内核源码

##### 获取源代码

git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git

git pull 更新最新分支

##### 使用补丁

patch -p1 < ../patch-x.y.z

用补丁的形式发布对源码的修改，不需要下载全部的源码压缩，只需要给旧的版本打上一个增量补丁，让其旧貌新颜，节约带宽，节省时间。

#### 内核源码树

* arch：特定体系结构的源码；

* block: 块儿设备I/O层；

* crypto: 加密API;

* Documentation: 内核源码文档；

* drivers: 设备驱动程序；

* firmware: 使用某些驱动程序需要的设备固件；

* fs: VFS和各种文件系统；

* include: 内核头文件；

* init: 内核引导和初始化；

* ipc: 进程间通信代码；

* kernel： 像调度程序这样的核心子系统；

* lib: 通用内核函数；

* mm: 内存管理子系统和VM;

* net: 网络子系统；

* samples: 示范，示例代码；

* scripts: 编译内核需要的脚本；

* security: Linux安全模块；

* sound: 语音子系统；

* usr: 早期用户空间代码；

* tools: 在linux开发中有用的工具；

* virt: 虚拟化基础结构；

* COPYING: 内核许可证；

* CREDITS: 开发者列表；

* MAINTAINERS: 维护者列表；

* Makefile: 基本编译；

#### 编译内核

##### 配置内核

make config    /    make menuconfig  / make gconfig

make defconfig  为体系结构构建一个配置文件 .config

make oldconfig 

make 

##### 减少编译垃圾信息

make > /dev/null 把输出信息重定向到永无返回值的黑洞/dev/null

##### 安装新内核

make -jn 多核编译

怎么安装和体系结构以及启动引导工具(boot loader)息息相关；

make modules_install 可以把已经编译好的模块安装到正确的主目录/lib/modules下；

#### 内核开发的特点

相对于应用程序的开发，内核开发有一些独特之处：

* 内核编译的时候既不能访问C库也不能访问标准的C头文件；

* 内核变成必须使用GNU C：Linux的内核混合使用了C语言和汇编语言，在偏近体系结构的底层或者执行时间严格要求的地方用汇编语言，而内核其他部分代码都是C语言编写的；

* 没有像用户空间那样有内存保护机制：如果用户程序师徒进行一次非法的内存访问，内核会发现错误，发送SIGSEGV信号，结束整个进程，如果内核自己非法访问了内存，后果很难控制，内核中，不应该去做访问非法的内存地址，引用空指针，否则会死掉，内核中内存都不分页，也就是说，每用掉一个字节，物理内存就减少一个字节；

* 内核编程时候难以执行浮点运算；

* 内核给每个进程只有一个很小的定长堆栈：用户空间可以从栈上分配大量的空间存放变量，内核栈准确大小随体系结构而变，在编译时候可以配置，4KB或者8KB，32位机的内核栈是8KB，64位的是16KB;

* 由于内核支持异步中断，抢占和SMP，因此必须时刻注意同步和并发：内核支持对称多处理器系统(SMP)，所以没有适当的保护同时在两个或者两个以上的处理器上执行的内核代码很可能同时访问共享的同一个资源，中断是异步到来的，完全不顾及当时正在执行的代码，解决竞争的办法是自旋锁和信号量；

* 要考虑可移植性的重要性： 用户空间的不太注意移植问题，然而LINUX是一个可移植的操作系统，就是所，大部分C代码应该与体系结构无关，许多不同的体系结构中都能编译执行，必须把与体系结构相关的代码从内核代码树德特定目录中适当的分离出来，诸如保持字节序，64位对齐，不假定字长和页面长度等一系列准则都有助于移植性；
